import random
import numpy as np
from typing import Optional
from pydantic import Field, BaseModel, model_validator

from w9_pathfinding.envs import Graph

RANDOM = "random"


class EnvFactory(BaseModel):
    random_seed: Optional[int] = None

    class Config:
        extra = "forbid"

    def __init__(self, **data):
        super().__init__(**data)
        self._rng = np.random.default_rng(self.random_seed)

    @model_validator(mode="after")
    def check_weights(self):
        min_weight = getattr(self, "min_weight", None)
        max_weight = getattr(self, "max_weight", None)
        if (
            min_weight is not None
            and max_weight is not None
            and min_weight > max_weight
        ):
            raise ValueError("min_weight must be less than or equal to max_weight.")

        return self

    def __call__(self):
        raise NotImplementedError()


class GraphFactory(EnvFactory):
    """
    A factory for generating random graphs.
    Note. Graphs generated by this factory are not guaranteed to be fully connected.

    Parameters
    ----------
    num_vertices : int
        Number of nodes in the graph.

    branching_factor : float
        Average number of outgoing edges per node.
        The total number of edges in the graph will be approximately:
        (branching_factor * num_vertices) / (1 if directed else 2).

    weighted : bool, default=False
        If True, edges are assigned random weights in the range [min_weight, max_weight]

    min_weight : float, default=0.0
        Minimum edge weight when `weighted` is True

    max_weight : float, default=1.0
        Maximum edge weight when `weighted` is True

    directed : bool, default=True
        If True, creates a directed graph (each edge has a direction).
        If False, creates an undirected graph

    allow_multiedges : bool, default=True
        If True, multiple edges between the same pair of nodes are allowed

    allow_selfloops : bool, default=True
        allows edges to connect a vertex to itself

    Usage
    -----
    >>> factory = GraphFactory(num_vertices=100, branching_factor=3.5, weighted=True)
    >>> graph = factory()
    >>> graph = factory()  # different graph
    """

    num_vertices: int = Field(..., gt=0)
    branching_factor: float = Field(..., ge=0.0)
    weighted: bool = False
    min_weight: float = Field(0.0, ge=0.0)
    max_weight: float = Field(1.0, ge=0.0)
    directed: bool = True
    allow_multiedges: bool = True
    allow_selfloops: bool = True

    @model_validator(mode="after")
    def validate_branching_factor(self):
        if not self.allow_multiedges:
            max_branching_factor = self.num_vertices - 1
            if self.allow_selfloops:
                max_branching_factor += 1
            if self.branching_factor > max_branching_factor:
                raise ValueError(
                    f"branching_factor ({self.branching_factor}) exceeds max possible "
                    f"outgoing edges per node ({max_branching_factor}) without multiedges."
                )

        return self

    def __call__(self) -> Graph:
        return Graph(
            num_vertices=self.num_vertices,
            directed=self.directed,
            edges=self._generate_edges(),
        )

    def _generate_edges(self):

        if self.directed:
            all_edges = [
                (v, e)
                for v in range(self.num_vertices)
                for e in range(self.num_vertices)
                if self.allow_selfloops or v != e
            ]
        else:
            all_edges = []
            for v in range(self.num_vertices):
                s = v if self.allow_selfloops else v + 1
                all_edges += [(v, e) for e in range(s, self.num_vertices)]

        num_edges = int(self.branching_factor * self.num_vertices)
        if not self.directed:
            # For undirected graphs, each edge contributes 
            # to the branching_factor of both connected nodes.
            num_edges //= 2

        if not self.allow_multiedges and num_edges > len(all_edges):
            raise ValueError(
                f"Cannot create {num_edges} unique edges "
                f"from only {len(all_edges)} possible combinations "
                f"(directed={self.directed}, self-loops={self.allow_selfloops})"
            )

        edges = self._rng.choice(all_edges, num_edges, replace=self.allow_multiedges)

        if self.weighted:
            weights = self._rng.uniform(
                self.min_weight, self.max_weight, size=len(edges)
            )
            edges = [(v, e, w) for (v, e), w in zip(edges, weights)]

        return edges
